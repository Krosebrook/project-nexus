{
  "findings": [
    {
      "src": "dashboard_widgets",
      "col": "user_id",
      "tgt": "users.id",
      "issue": "TEXT column references BIGINT - type mismatch; no FK constraint exists",
      "proposed_fix": "Add FK constraint or document as external reference if user_id maps to users.user_id (TEXT)"
    },
    {
      "src": "dashboard_widgets",
      "col": "user_id",
      "tgt": "users.user_id",
      "issue": "Column type matches (TEXT→TEXT) but no FK constraint exists",
      "proposed_fix": "Add FK: dashboard_widgets.user_id → users.user_id with ON DELETE CASCADE"
    },
    {
      "src": "deployment_approvals",
      "col": "approved_by",
      "tgt": "users.id",
      "issue": "BIGINT[] array references BIGINT - cannot create standard FK on array",
      "proposed_fix": "Use CHECK constraint + trigger to validate all array elements exist in users.id, or use junction table"
    },
    {
      "src": "alert_escalations",
      "col": "user_ids",
      "tgt": "users.id",
      "issue": "BIGINT[] array references BIGINT - cannot create standard FK on array",
      "proposed_fix": "Use CHECK constraint + trigger to validate all array elements exist in users.id, or use junction table"
    },
    {
      "src": "approval_rules",
      "col": "allowed_approvers",
      "tgt": "users.id",
      "issue": "BIGINT[] array references BIGINT - cannot create standard FK on array",
      "proposed_fix": "Use CHECK constraint + trigger to validate all array elements exist in users.id, or use junction table"
    },
    {
      "src": "alert_condition_groups",
      "col": "condition_ids",
      "tgt": "alert_conditions.id",
      "issue": "BIGINT[] array references BIGINT - cannot create standard FK on array",
      "proposed_fix": "Use CHECK constraint + trigger to validate all array elements exist in alert_conditions.id, or use junction table"
    },
    {
      "src": "user_preferences",
      "col": "user_id",
      "tgt": "users.user_id",
      "issue": "TEXT column has no FK constraint; orphaned records possible",
      "proposed_fix": "Add FK: user_preferences.user_id → users.user_id with ON DELETE CASCADE"
    },
    {
      "src": "error_logs",
      "col": "user_id",
      "tgt": "users.user_id",
      "issue": "TEXT column has no FK constraint; nullable, orphaned records possible",
      "proposed_fix": "Add FK: error_logs.user_id → users.user_id with ON DELETE SET NULL"
    },
    {
      "src": "deployment_queue",
      "col": "requested_by",
      "tgt": "users.user_id",
      "issue": "TEXT column has no FK constraint; nullable, orphaned records possible",
      "proposed_fix": "Add FK: deployment_queue.requested_by → users.user_id with ON DELETE SET NULL"
    },
    {
      "src": "deployment_schedules",
      "col": "created_by",
      "tgt": "users.user_id",
      "issue": "TEXT column has no FK constraint; nullable, orphaned records possible",
      "proposed_fix": "Add FK: deployment_schedules.created_by → users.user_id with ON DELETE SET NULL"
    },
    {
      "src": "database_backups",
      "col": "created_by",
      "tgt": "users.user_id",
      "issue": "TEXT column has no FK constraint; nullable, orphaned records possible",
      "proposed_fix": "Add FK: database_backups.created_by → users.user_id with ON DELETE SET NULL"
    },
    {
      "src": "backup_restore_history",
      "col": "restored_by",
      "tgt": "users.user_id",
      "issue": "TEXT column has no FK constraint; nullable, orphaned records possible",
      "proposed_fix": "Add FK: backup_restore_history.restored_by → users.user_id with ON DELETE SET NULL"
    },
    {
      "src": "migration_rollback_audit",
      "col": "initiated_by",
      "tgt": "users.user_id",
      "issue": "TEXT column has no FK constraint; nullable, orphaned records possible",
      "proposed_fix": "Add FK: migration_rollback_audit.initiated_by → users.user_id with ON DELETE SET NULL"
    },
    {
      "src": "artifact_versions",
      "col": "created_by",
      "tgt": "users.user_id",
      "issue": "TEXT column has no FK constraint; nullable, orphaned records possible",
      "proposed_fix": "Add FK: artifact_versions.created_by → users.user_id with ON DELETE SET NULL"
    },
    {
      "src": "error_logs",
      "col": "session_id",
      "tgt": null,
      "issue": "No target table for session tracking; sessions table missing",
      "proposed_fix": "Either create sessions table with FK, or document as external session ID (no FK needed)"
    },
    {
      "src": "sync_events",
      "col": "client_id",
      "tgt": null,
      "issue": "No target table for client tracking; clients table missing",
      "proposed_fix": "Either create clients/devices table with FK, or document as external client ID (no FK needed)"
    }
  ],
  "migrations": [
    {
      "file": "025_add_missing_text_fk_constraints.up.sql",
      "up": "-- Add missing foreign key constraints for TEXT columns referencing users.user_id\n-- This migration is safe and reversible\n\nBEGIN;\n\n-- dashboard_widgets.user_id → users.user_id\nDO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_constraint \n    WHERE conname = 'dashboard_widgets_user_id_fkey'\n  ) THEN\n    -- First, clean up any orphaned records\n    DELETE FROM dashboard_widgets\n    WHERE user_id NOT IN (SELECT user_id FROM users);\n    \n    ALTER TABLE dashboard_widgets \n      ADD CONSTRAINT dashboard_widgets_user_id_fkey \n      FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE;\n  END IF;\nEND $$;\n\n-- user_preferences.user_id → users.user_id\nDO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_constraint \n    WHERE conname = 'user_preferences_user_id_fkey'\n  ) THEN\n    DELETE FROM user_preferences\n    WHERE user_id NOT IN (SELECT user_id FROM users);\n    \n    ALTER TABLE user_preferences \n      ADD CONSTRAINT user_preferences_user_id_fkey \n      FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE;\n  END IF;\nEND $$;\n\n-- error_logs.user_id → users.user_id (nullable)\nDO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_constraint \n    WHERE conname = 'error_logs_user_id_fkey'\n  ) THEN\n    DELETE FROM error_logs\n    WHERE user_id IS NOT NULL \n      AND user_id NOT IN (SELECT user_id FROM users);\n    \n    ALTER TABLE error_logs \n      ADD CONSTRAINT error_logs_user_id_fkey \n      FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE SET NULL;\n  END IF;\nEND $$;\n\n-- deployment_queue.requested_by → users.user_id (nullable)\nDO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_constraint \n    WHERE conname = 'deployment_queue_requested_by_fkey'\n  ) THEN\n    UPDATE deployment_queue\n    SET requested_by = NULL\n    WHERE requested_by IS NOT NULL \n      AND requested_by NOT IN (SELECT user_id FROM users);\n    \n    ALTER TABLE deployment_queue \n      ADD CONSTRAINT deployment_queue_requested_by_fkey \n      FOREIGN KEY (requested_by) REFERENCES users(user_id) ON DELETE SET NULL;\n  END IF;\nEND $$;\n\n-- deployment_schedules.created_by → users.user_id (nullable)\nDO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_constraint \n    WHERE conname = 'deployment_schedules_created_by_fkey'\n  ) THEN\n    UPDATE deployment_schedules\n    SET created_by = NULL\n    WHERE created_by IS NOT NULL \n      AND created_by NOT IN (SELECT user_id FROM users);\n    \n    ALTER TABLE deployment_schedules \n      ADD CONSTRAINT deployment_schedules_created_by_fkey \n      FOREIGN KEY (created_by) REFERENCES users(user_id) ON DELETE SET NULL;\n  END IF;\nEND $$;\n\n-- database_backups.created_by → users.user_id (nullable)\nDO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_constraint \n    WHERE conname = 'database_backups_created_by_fkey'\n  ) THEN\n    UPDATE database_backups\n    SET created_by = NULL\n    WHERE created_by IS NOT NULL \n      AND created_by NOT IN (SELECT user_id FROM users);\n    \n    ALTER TABLE database_backups \n      ADD CONSTRAINT database_backups_created_by_fkey \n      FOREIGN KEY (created_by) REFERENCES users(user_id) ON DELETE SET NULL;\n  END IF;\nEND $$;\n\n-- backup_restore_history.restored_by → users.user_id (nullable)\nDO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_constraint \n    WHERE conname = 'backup_restore_history_restored_by_fkey'\n  ) THEN\n    UPDATE backup_restore_history\n    SET restored_by = NULL\n    WHERE restored_by IS NOT NULL \n      AND restored_by NOT IN (SELECT user_id FROM users);\n    \n    ALTER TABLE backup_restore_history \n      ADD CONSTRAINT backup_restore_history_restored_by_fkey \n      FOREIGN KEY (restored_by) REFERENCES users(user_id) ON DELETE SET NULL;\n  END IF;\nEND $$;\n\n-- migration_rollback_audit.initiated_by → users.user_id (nullable)\nDO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_constraint \n    WHERE conname = 'migration_rollback_audit_initiated_by_fkey'\n  ) THEN\n    UPDATE migration_rollback_audit\n    SET initiated_by = NULL\n    WHERE initiated_by IS NOT NULL \n      AND initiated_by NOT IN (SELECT user_id FROM users);\n    \n    ALTER TABLE migration_rollback_audit \n      ADD CONSTRAINT migration_rollback_audit_initiated_by_fkey \n      FOREIGN KEY (initiated_by) REFERENCES users(user_id) ON DELETE SET NULL;\n  END IF;\nEND $$;\n\n-- artifact_versions.created_by → users.user_id (nullable)\nDO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 FROM pg_constraint \n    WHERE conname = 'artifact_versions_created_by_fkey'\n  ) THEN\n    UPDATE artifact_versions\n    SET created_by = NULL\n    WHERE created_by IS NOT NULL \n      AND created_by NOT IN (SELECT user_id FROM users);\n    \n    ALTER TABLE artifact_versions \n      ADD CONSTRAINT artifact_versions_created_by_fkey \n      FOREIGN KEY (created_by) REFERENCES users(user_id) ON DELETE SET NULL;\n  END IF;\nEND $$;\n\n-- Create indexes for the new foreign keys\nCREATE INDEX IF NOT EXISTS idx_error_logs_user_id_fk ON error_logs(user_id) WHERE user_id IS NOT NULL;\nCREATE INDEX IF NOT EXISTS idx_deployment_queue_requested_by_fk ON deployment_queue(requested_by) WHERE requested_by IS NOT NULL;\nCREATE INDEX IF NOT EXISTS idx_deployment_schedules_created_by_fk ON deployment_schedules(created_by) WHERE created_by IS NOT NULL;\nCREATE INDEX IF NOT EXISTS idx_database_backups_created_by_fk ON database_backups(created_by) WHERE created_by IS NOT NULL;\nCREATE INDEX IF NOT EXISTS idx_backup_restore_history_restored_by_fk ON backup_restore_history(restored_by) WHERE restored_by IS NOT NULL;\nCREATE INDEX IF NOT EXISTS idx_migration_rollback_audit_initiated_by_fk ON migration_rollback_audit(initiated_by) WHERE initiated_by IS NOT NULL;\nCREATE INDEX IF NOT EXISTS idx_artifact_versions_created_by_fk ON artifact_versions(created_by) WHERE created_by IS NOT NULL;\n\nCOMMIT;",
      "down": "-- Rollback: Remove foreign key constraints added in migration 025\n\nBEGIN;\n\nALTER TABLE dashboard_widgets DROP CONSTRAINT IF EXISTS dashboard_widgets_user_id_fkey;\nALTER TABLE user_preferences DROP CONSTRAINT IF EXISTS user_preferences_user_id_fkey;\nALTER TABLE error_logs DROP CONSTRAINT IF EXISTS error_logs_user_id_fkey;\nALTER TABLE deployment_queue DROP CONSTRAINT IF EXISTS deployment_queue_requested_by_fkey;\nALTER TABLE deployment_schedules DROP CONSTRAINT IF EXISTS deployment_schedules_created_by_fkey;\nALTER TABLE database_backups DROP CONSTRAINT IF EXISTS database_backups_created_by_fkey;\nALTER TABLE backup_restore_history DROP CONSTRAINT IF EXISTS backup_restore_history_restored_by_fkey;\nALTER TABLE migration_rollback_audit DROP CONSTRAINT IF EXISTS migration_rollback_audit_initiated_by_fkey;\nALTER TABLE artifact_versions DROP CONSTRAINT IF EXISTS artifact_versions_created_by_fkey;\n\nDROP INDEX IF EXISTS idx_error_logs_user_id_fk;\nDROP INDEX IF EXISTS idx_deployment_queue_requested_by_fk;\nDROP INDEX IF EXISTS idx_deployment_schedules_created_by_fk;\nDROP INDEX IF EXISTS idx_database_backups_created_by_fk;\nDROP INDEX IF EXISTS idx_backup_restore_history_restored_by_fk;\nDROP INDEX IF EXISTS idx_migration_rollback_audit_initiated_by_fk;\nDROP INDEX IF EXISTS idx_artifact_versions_created_by_fk;\n\nCOMMIT;"
    },
    {
      "file": "026_add_array_fk_validation.up.sql",
      "up": "-- Add validation for BIGINT[] array columns that reference other tables\n-- Uses triggers instead of standard FKs since Postgres doesn't support FK on arrays\n\nBEGIN;\n\n-- Function to validate user IDs in BIGINT arrays\nCREATE OR REPLACE FUNCTION validate_user_ids_array(user_ids BIGINT[])\nRETURNS BOOLEAN AS $$\nDECLARE\n  invalid_count INTEGER;\nBEGIN\n  IF user_ids IS NULL OR array_length(user_ids, 1) IS NULL THEN\n    RETURN TRUE;\n  END IF;\n  \n  SELECT COUNT(*) INTO invalid_count\n  FROM unnest(user_ids) AS uid\n  WHERE uid NOT IN (SELECT id FROM users);\n  \n  RETURN invalid_count = 0;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Trigger function for deployment_approvals.approved_by\nCREATE OR REPLACE FUNCTION check_deployment_approvals_approved_by()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF NOT validate_user_ids_array(NEW.approved_by) THEN\n    RAISE EXCEPTION 'Invalid user IDs in approved_by array';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS trg_check_deployment_approvals_approved_by ON deployment_approvals;\nCREATE TRIGGER trg_check_deployment_approvals_approved_by\n  BEFORE INSERT OR UPDATE ON deployment_approvals\n  FOR EACH ROW\n  EXECUTE FUNCTION check_deployment_approvals_approved_by();\n\n-- Trigger function for alert_escalations.user_ids\nCREATE OR REPLACE FUNCTION check_alert_escalations_user_ids()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF NOT validate_user_ids_array(NEW.user_ids) THEN\n    RAISE EXCEPTION 'Invalid user IDs in user_ids array';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS trg_check_alert_escalations_user_ids ON alert_escalations;\nCREATE TRIGGER trg_check_alert_escalations_user_ids\n  BEFORE INSERT OR UPDATE ON alert_escalations\n  FOR EACH ROW\n  EXECUTE FUNCTION check_alert_escalations_user_ids();\n\n-- Trigger function for approval_rules.allowed_approvers\nCREATE OR REPLACE FUNCTION check_approval_rules_allowed_approvers()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF NOT validate_user_ids_array(NEW.allowed_approvers) THEN\n    RAISE EXCEPTION 'Invalid user IDs in allowed_approvers array';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS trg_check_approval_rules_allowed_approvers ON approval_rules;\nCREATE TRIGGER trg_check_approval_rules_allowed_approvers\n  BEFORE INSERT OR UPDATE ON approval_rules\n  FOR EACH ROW\n  EXECUTE FUNCTION check_approval_rules_allowed_approvers();\n\n-- Function to validate alert condition IDs in arrays\nCREATE OR REPLACE FUNCTION validate_condition_ids_array(condition_ids BIGINT[])\nRETURNS BOOLEAN AS $$\nDECLARE\n  invalid_count INTEGER;\nBEGIN\n  IF condition_ids IS NULL OR array_length(condition_ids, 1) IS NULL THEN\n    RETURN TRUE;\n  END IF;\n  \n  SELECT COUNT(*) INTO invalid_count\n  FROM unnest(condition_ids) AS cid\n  WHERE cid NOT IN (SELECT id FROM alert_conditions);\n  \n  RETURN invalid_count = 0;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Trigger function for alert_condition_groups.condition_ids\nCREATE OR REPLACE FUNCTION check_alert_condition_groups_condition_ids()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF NOT validate_condition_ids_array(NEW.condition_ids) THEN\n    RAISE EXCEPTION 'Invalid condition IDs in condition_ids array';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nDROP TRIGGER IF EXISTS trg_check_alert_condition_groups_condition_ids ON alert_condition_groups;\nCREATE TRIGGER trg_check_alert_condition_groups_condition_ids\n  BEFORE INSERT OR UPDATE ON alert_condition_groups\n  FOR EACH ROW\n  EXECUTE FUNCTION check_alert_condition_groups_condition_ids();\n\nCOMMIT;",
      "down": "-- Rollback: Remove array validation triggers\n\nBEGIN;\n\nDROP TRIGGER IF EXISTS trg_check_deployment_approvals_approved_by ON deployment_approvals;\nDROP TRIGGER IF EXISTS trg_check_alert_escalations_user_ids ON alert_escalations;\nDROP TRIGGER IF EXISTS trg_check_approval_rules_allowed_approvers ON approval_rules;\nDROP TRIGGER IF EXISTS trg_check_alert_condition_groups_condition_ids ON alert_condition_groups;\n\nDROP FUNCTION IF EXISTS check_deployment_approvals_approved_by();\nDROP FUNCTION IF EXISTS check_alert_escalations_user_ids();\nDROP FUNCTION IF EXISTS check_approval_rules_allowed_approvers();\nDROP FUNCTION IF EXISTS check_alert_condition_groups_condition_ids();\nDROP FUNCTION IF EXISTS validate_user_ids_array(BIGINT[]);\nDROP FUNCTION IF EXISTS validate_condition_ids_array(BIGINT[]);\n\nCOMMIT;"
    }
  ],
  "dry_run_cmd": "psql $DATABASE_URL -f backend/db/migrations/024_comprehensive_fk_audit.sql > fk_audit_results.txt 2>&1",
  "verification_sql": [
    "-- Verify all FK constraints exist",
    "SELECT count(*) AS total_fks FROM information_schema.table_constraints WHERE constraint_type = 'FOREIGN KEY' AND table_schema = 'public';",
    "",
    "-- Verify no orphaned records exist after cleanup",
    "SELECT 'dashboard_widgets' AS table_name, COUNT(*) AS orphans FROM dashboard_widgets WHERE user_id NOT IN (SELECT user_id FROM users);",
    "SELECT 'user_preferences' AS table_name, COUNT(*) AS orphans FROM user_preferences WHERE user_id NOT IN (SELECT user_id FROM users);",
    "SELECT 'error_logs' AS table_name, COUNT(*) AS orphans FROM error_logs WHERE user_id IS NOT NULL AND user_id NOT IN (SELECT user_id FROM users);",
    "",
    "-- Verify indexes exist for FK columns",
    "SELECT schemaname, tablename, indexname FROM pg_indexes WHERE schemaname = 'public' AND indexname LIKE '%_fkey' OR indexname LIKE '%_fk' ORDER BY tablename;",
    "",
    "-- Test array validation triggers",
    "DO $$ BEGIN",
    "  BEGIN",
    "    INSERT INTO deployment_approvals (deployment_id, approved_by) VALUES (1, ARRAY[999999]::BIGINT[]);",
    "    RAISE EXCEPTION 'Trigger validation failed: should have rejected invalid user ID';",
    "  EXCEPTION WHEN others THEN",
    "    IF SQLERRM NOT LIKE '%Invalid user IDs%' THEN",
    "      RAISE;",
    "    END IF;",
    "  END;",
    "END $$;",
    "",
    "-- Verify all tables have proper ON DELETE/UPDATE rules",
    "SELECT",
    "  tc.table_name,",
    "  kcu.column_name,",
    "  ccu.table_name AS foreign_table,",
    "  rc.delete_rule,",
    "  rc.update_rule",
    "FROM information_schema.table_constraints tc",
    "JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name",
    "JOIN information_schema.constraint_column_usage ccu ON tc.constraint_name = ccu.constraint_name",
    "JOIN information_schema.referential_constraints rc ON tc.constraint_name = rc.constraint_name",
    "WHERE tc.constraint_type = 'FOREIGN KEY'",
    "  AND tc.table_schema = 'public'",
    "ORDER BY tc.table_name, kcu.column_name;"
  ],
  "risk_notes": "RISK ASSESSMENT:\n\n1. DATA CLEANUP (Medium Risk):\n   - Migration 025 deletes orphaned records from dashboard_widgets, user_preferences, and error_logs\n   - For nullable columns, sets values to NULL instead of deleting rows\n   - MITIGATION: Create backup before applying: pg_dump -Fc $DATABASE_URL > backup_before_fk_fix.dump\n\n2. ARRAY VALIDATION TRIGGERS (Low Risk):\n   - Migration 026 adds triggers that validate array contents on INSERT/UPDATE\n   - Does NOT retroactively clean existing data\n   - RECOMMENDATION: Run data cleanup script before applying migration 026\n\n3. PERFORMANCE IMPACT (Low-Medium):\n   - New FK constraints add lookup overhead on INSERT/UPDATE/DELETE\n   - Array validation triggers execute on every write to affected tables\n   - MITIGATION: All new indexes are partial (WHERE IS NOT NULL) to minimize storage\n\n4. DEPLOYMENT DEPENDENCIES:\n   - Migration 025 requires users table to exist and be populated\n   - If users table is empty, most historical data will be cleaned up\n   - RECOMMENDATION: Seed at least one default user before applying\n\n5. REVERSIBILITY:\n   - All migrations have full DOWN scripts\n   - DOWN scripts remove constraints but do NOT restore deleted data\n   - CRITICAL: Backup before applying, test in staging first\n\nASSUMPTIONS:\n- user_id columns (TEXT) reference users.user_id, not users.id (BIGINT)\n- error_logs.session_id and sync_events.client_id are external IDs (no FK needed)\n- Array columns are intentionally denormalized for performance (triggers preferred over junction tables)\n- All existing data in production follows referential integrity (minimal cleanup needed)\n\nRECOMMENDED APPLICATION ORDER:\n1. Create full database backup\n2. Run audit query (024_comprehensive_fk_audit.sql) and review orphan counts\n3. If orphan counts are acceptable, apply 025_add_missing_text_fk_constraints.up.sql\n4. Verify with verification_sql queries\n5. Apply 026_add_array_fk_validation.up.sql\n6. Run final verification queries\n7. Monitor application logs for any constraint violations"
}
